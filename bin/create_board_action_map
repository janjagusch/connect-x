#! python

from datetime import datetime
import gzip
import json
import logging
import sys

from kaggle_environments import make
import numpy as np

from connect_x.minimax import minimax, ConnectXNode
from connect_x import utils
from connect_x.logger import setup_logger
from submission import FORECAST_DEPTH


_LOGGER = setup_logger(__name__)


def flatten_tree(node, flat_tree=None):
    """
    Flatten a tree of ConnectXNodes into a dictionary.

    Args:
        node (connect_x.minimax.tree.ConnectXNode): The root node.
        flat_tree (dict, optional): Where to append the nodes.

    Returns:
        dict: The flat tree as a dictionary.
    """
    flat_tree = flat_tree or {}
    flat_tree[utils.board_hash(node.observation.board, node.observation.mark)] = node
    for child in node.children:
        flatten_tree(child, flat_tree)
    return flat_tree


def best_action(node):
    """
    Returns the best action for a maximize node.

    Args:
        node (connect_x.minimax.tree.ConnectXNode): The root node.

    Returns:
        int: The action.
    """
    assert node.maximize
    if not node.children:
        return None
    return int(node.children[np.argmax([child.value[0] for child in node.children])].action)


def write_module(flat_tree, forecast_depth):
    board_action_map_binary = gzip.compress(json.dumps(flat_tree).encode("ascii"))
    with open("connect_x/board_action_map.py", "w") as file_pointer:
        file_pointer.write(
            '"""\nThis module contains pre-calculated board actions.\n"""\n'
        )
        file_pointer.write("import gzip\nimport json\n\n")
        file_pointer.write(f"FORECAST_DEPTH = {forecast_depth}\n\n")
        file_pointer.write("# pylint: disable=line-too-long\n")
        file_pointer.write(f'_BOARD_ACTION_MAP_BINARY = {board_action_map_binary}\n\n')
        file_pointer.write("# pylint: enable=line-too-long\n")
        file_pointer.write("BOARD_ACTION_MAP = json.loads(gzip.decompress(_BOARD_ACTION_MAP_BINARY))\n")


if __name__ == "__main__":

    MAX_DEPTH  = 7
    _LOGGER.info(f"MAX_DEPTH={MAX_DEPTH}")

    env = make("connectx")
    observation = env.state[0].observation
    configuration = env.configuration

    node_1 = ConnectXNode(observation, configuration)
    node_2 = ConnectXNode(observation, configuration, mark=1)

    _LOGGER.info("Starting Minimax ...")
    start = datetime.now()
    minimax(node_1, max_depth=MAX_DEPTH)
    minimax(node_2, max_depth=MAX_DEPTH, maximize=False)
    end = datetime.now()
    _LOGGER.info(f"Minimax completed. Time taken: {end - start}.")

    _LOGGER.info("Flattening Minimax tree ...")
    start = datetime.now()
    flat_tree_1 = flatten_tree(node_1)
    flat_tree_2 = flatten_tree(node_2)
    end = datetime.now()
    _LOGGER.info(f"Flattening completed. Time taken: {end - start}.")
    flat_tree_1 = {key: value for key, value in flat_tree_1.items() if value.maximize}
    flat_tree_2 = {key: value for key, value in flat_tree_2.items() if value.maximize}
    flat_tree = {**flat_tree_1, **flat_tree_2}
    flat_tree = {key: value for key, value in flat_tree.items() if value.depth < (MAX_DEPTH - FORECAST_DEPTH)}
    flat_tree = {key: best_action(value) for key, value in flat_tree.items()}
    _LOGGER.info(f"Flat tree has {len(flat_tree)} entries.")

    _LOGGER.info("Writing dictionary into module ...")
    write_module(flat_tree, MAX_DEPTH)
    _LOGGER.info("Writing completed.")
